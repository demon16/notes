> gcc是linux平台的C编译器, 编译后再当前目录下生成可执行文件*a.out*, 直接在命令行输入这个可执行文件的路径就可以执行它.

gcc 参数
  - -E  Preprocess only; do not compile, assemble or link.
  - -S  Compile only; do not assemble or link.
  - -c  Compile and assemble, but do not link.
  - -o \<file\> Place the output into \<file\>.
  - -Wall 提示所有警告信息.
  - -lm 告诉编译器, 我们的程序中要用到的一些函数需要到`/lib/libm.so`库中找.

> 局部变量可以用任意类型相符的表达式来初始化, 而全局变量只能用常量表达式初始化. 全局变量的初始之要求保存在编译生成的目标代码中, 所以必须在编译时就能计算出来.

> 如果全局变量在定义时不初始化, 则初始值是0, 也就是说, 整型的就是0, 字符型的就是'\0', 浮点型的就是0.0.

> 如果局部变量在定义时不初始化, 则初始值是不确定(每次调用这个函数时局部变量的初值可能不一样, 运行环境不同, 函数的调用次序不同, 都会影响到局部变量的初值.)的.

> `switch`分支的`case`后面跟的必须是常量表达式, 因为这个值必须在编译时计算出来. `case`后面跟的常量表达式的值必须是可以精确比较的整型或字符型.

> `for(int i = 1; i <= n; i++)` 如果这样定义, 那么变量`i`只是for循环中的局部变量而不是整个函数的局部变量. 这个程序用`gcc`编译要加上选项`-std=c99`. 在C++中这种写法很常见, 但是在C语言中, 考虑到兼容性, 不建议这种写法.

> 通常goto语句只用于在函数末尾做出错处理(例如释放先前分配的资源, 恢复先前改动过的全局变量等), 函数中任何地方出现了错误条件都可以立即跳转到函数末尾, 处理完之后函数返回.

> 结构体的成员名和变量名不在同一命名空间, 但枚举的成员名和变量名却在同一命名空间.

> 数组和结构体虽然有很多相似之处, 但也有一个显著的不同: 数组不能互相传值. 例如这样是错误的
```c
int a[5], b[5] = {4, 3, 2};
a = b;
```
> 对于数组类型有一条特殊规则: 数组名做右值使用时, 自动转换成指向数组首元素的指针.

> C99引入了新的特性, 规定数组长度表达式也可以包含变量, 称为变长数组(VLA, Variable Length Array), VLA只能定义为函数的局部变量.但是不推荐使用.

> C语言的设计精神是: 相信每个C程序员都是高手, 不要阻止程序员去干他们需要干的事, 高手们使用`count[-1]`这种技巧其实并不少见, 不能当作错误. 哈哈哈哈

> C标准库中生成伪随机(Pseudorandom)数的是`rand`函数, 使用这个函数需要包含头文件`stdlib.h`, 它没有参数, 返回的是一个介于`0`和`RAND_MAX`之间的接近均匀分布(Uniform Distribution)的整数. `RAND_MAX`是头文件中定义的一个常量, 在不同平台上有不同取值.

> 用`#define`定义一个常量. 实际上编译器的工作分为两个步骤, 先是预处理(Preprocess), 然后才是编译, 用gcc的`-E`选项可以看到预处理之后, 编译之前的程序.

> 像`#include`和`#define`这种以`#`号开头的语法元素称为预处理指示(Preprocess Directive). 此外， 用`cpp man.c`也可以达到同样的效果, 只做预处理而不编译, `cpp`表示`C preprocessor`.

> `define`定义是在预处理阶段处理的, 而`枚举`是在编译阶段处理的.

> 剪刀石头布算法: `(man - computer + 4) % 3 - 1`
